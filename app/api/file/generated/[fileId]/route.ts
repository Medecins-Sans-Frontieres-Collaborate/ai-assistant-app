import { NextRequest, NextResponse } from 'next/server';

import { CodeInterpreterFileService } from '@/lib/services/chat/codeInterpreter/CodeInterpreterFileService';
import { getAzureMonitorLogger } from '@/lib/services/observability';

import { auth } from '@/auth';

/**
 * GET /api/file/generated/[fileId]
 *
 * Downloads a file generated by Code Interpreter.
 *
 * These files are stored in AI Foundry's file storage and are created
 * during Code Interpreter execution (charts, processed data, etc.).
 *
 * Query parameters:
 * - download: If 'true', sets Content-Disposition to attachment
 * - filename: Optional filename for download (default: generated_file)
 */
export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ fileId: string }> },
) {
  const logger = getAzureMonitorLogger();
  const startTime = Date.now();

  const { fileId } = await params;
  const { searchParams } = new URL(request.url);
  const isDownload = searchParams.get('download') === 'true';
  const filename = searchParams.get('filename') || 'generated_file';

  // Validate fileId format (AI Foundry file IDs start with 'file-')
  if (!fileId || !fileId.startsWith('file-')) {
    return NextResponse.json(
      { error: 'Invalid file identifier' },
      { status: 400 },
    );
  }

  // Authenticate user
  const session = await auth();
  if (!session) {
    return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });
  }

  try {
    const codeInterpreterFileService = new CodeInterpreterFileService();

    // Get file metadata to determine MIME type
    const fileMetadata = await codeInterpreterFileService.getFile(fileId);

    if (!fileMetadata) {
      return NextResponse.json({ error: 'File not found' }, { status: 404 });
    }

    // Download file content
    // Note: For generated files, we download directly from AI Foundry
    // The containerId is typically not needed for files with file- prefix
    const buffer = await codeInterpreterFileService.downloadGeneratedFile(
      fileId,
      '', // Container ID not needed for direct file access
    );

    // Determine content type from filename or default to octet-stream
    const contentType = getContentType(fileMetadata.filename || filename);

    // Log success
    const duration = Date.now() - startTime;
    void logger.logFileRetrievalSuccess({
      user: session.user,
      fileId,
      fileType: 'generated',
      duration,
    });

    // Build response headers
    const headers: HeadersInit = {
      'Content-Type': contentType,
      'Cache-Control': 'private, max-age=3600', // Cache for 1 hour
    };

    // Set download disposition if requested
    if (isDownload) {
      const downloadFilename = fileMetadata.filename || filename;
      headers['Content-Disposition'] =
        `attachment; filename="${encodeURIComponent(downloadFilename)}"`;
    }

    return new NextResponse(buffer, { headers });
  } catch (error) {
    console.error('[Generated File API] Error retrieving file:', error);

    // Log error
    void logger.logFileRetrievalError({
      user: session.user,
      fileId,
      fileType: 'generated',
      errorCode: 'GENERATED_FILE_RETRIEVAL_ERROR',
      errorMessage: error instanceof Error ? error.message : 'Unknown error',
    });

    // Check for specific error types
    if (error instanceof Error) {
      if (
        error.message.includes('not found') ||
        error.message.includes('404')
      ) {
        return NextResponse.json(
          { error: 'File not found or has expired' },
          { status: 404 },
        );
      }
    }

    return NextResponse.json(
      { error: 'Failed to retrieve generated file' },
      { status: 500 },
    );
  }
}

/**
 * Determines content type from filename extension.
 */
function getContentType(filename: string): string {
  const ext = filename.toLowerCase().split('.').pop();

  const contentTypes: Record<string, string> = {
    // Images
    png: 'image/png',
    jpg: 'image/jpeg',
    jpeg: 'image/jpeg',
    gif: 'image/gif',
    webp: 'image/webp',
    svg: 'image/svg+xml',

    // Data files
    csv: 'text/csv',
    json: 'application/json',
    xlsx: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
    xls: 'application/vnd.ms-excel',

    // Documents
    pdf: 'application/pdf',
    txt: 'text/plain',
    md: 'text/markdown',

    // Code
    py: 'text/x-python',
    html: 'text/html',
  };

  return contentTypes[ext || ''] || 'application/octet-stream';
}
